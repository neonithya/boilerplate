"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Deprecated = exports.GraphQLVariables = exports.GraphQL = exports.Config = exports.ResponseStatus = exports.Timeout = exports.ResponseTransformer = exports.RequestTransformer = exports.ResponseType = exports.Part = exports.Multipart = exports.FieldMap = exports.Field = exports.FormUrlEncoded = exports.QueryMap = exports.Query = exports.Queries = exports.QueryArrayFormat = exports.HeaderMap = exports.Header = exports.Headers = exports.Body = exports.Path = exports.BasePath = exports.OPTIONS = exports.HEAD = exports.DELETE = exports.PATCH = exports.PUT = exports.POST = exports.GET = void 0;
/**
 * Ensure the `__meta__` attribute is in the target object and `methodName` has been initialized.
 * @param target
 * @param methodName
 */
const ensureMeta = (target, methodName) => {
    if (!target.__meta__) {
        target.__meta__ = {};
    }
    if (!target.__meta__[methodName]) {
        target.__meta__[methodName] = {};
    }
};
/**
 * Register HTTP method and path in API method.
 * @param method
 * @param url
 * @param options
 */
const registerMethod = (method, url, options) => {
    return (target, methodName, descriptor) => {
        ensureMeta(target, methodName);
        target.__meta__[methodName].method = method;
        target.__meta__[methodName].path = url;
        target.__meta__[methodName].options = options;
    };
};
/**
 * GET decorator.
 * @param url
 * @param options
 * @sample @GET("/users")
 * @constructor
 */
const GET = (url, options) => {
    return registerMethod("GET", url, options);
};
exports.GET = GET;
/**
 * POST decorator.
 * @param url
 * @param options
 * @sample @POST("/users")
 * @constructor
 */
const POST = (url, options) => {
    return registerMethod("POST", url, options);
};
exports.POST = POST;
/**
 * PUT decorator.
 * @param url
 * @param options
 * @sample @PUT("/users/{userId}")
 * @constructor
 */
const PUT = (url, options) => {
    return registerMethod("PUT", url, options);
};
exports.PUT = PUT;
/**
 * PATCH decorator.
 * @param url
 * @param options
 * @sample @PATCH("/users/{userId}")
 * @constructor
 */
const PATCH = (url, options) => {
    return registerMethod("PATCH", url, options);
};
exports.PATCH = PATCH;
/**
 * DELETE decorator.
 * @param url
 * @param options
 * @sample @DELETE("/users/{userId}")
 * @constructor
 */
const DELETE = (url, options) => {
    return registerMethod("DELETE", url, options);
};
exports.DELETE = DELETE;
/**
 * HEAD decorator.
 * @param url
 * @param options
 * @sample @HEAD("/users/{userId}")
 * @constructor
 */
const HEAD = (url, options) => {
    return registerMethod("HEAD", url, options);
};
exports.HEAD = HEAD;
/**
 * OPTIONS decorator.
 * @param url
 * @param options
 * @sample @OPTIONS("/users/{userId}")
 * @constructor
 */
const OPTIONS = (url, options) => {
    return registerMethod("OPTIONS", url, options);
};
exports.OPTIONS = OPTIONS;
/**
 * Set base path for API service.
 * @param path
 * @sample @BasePath("/api/v1")
 * @constructor
 */
const BasePath = (path) => {
    return (target) => {
        ensureMeta(target.prototype, "basePath");
        target.prototype.__meta__.basePath = path;
    };
};
exports.BasePath = BasePath;
/**
 * Set path parameter for API endpoint.
 * @param paramName
 * @sample @Path("userId") userId: number
 * @constructor
 */
const Path = (paramName) => {
    return (target, methodName, paramIndex) => {
        ensureMeta(target, methodName);
        if (!target.__meta__[methodName].pathParams) {
            target.__meta__[methodName].pathParams = {};
        }
        target.__meta__[methodName].pathParams[paramIndex] = paramName;
    };
};
exports.Path = Path;
/**
 * Set body for API endpoint.
 * @param target
 * @param methodName
 * @param paramIndex
 * @sample @Body user: User
 * @constructor
 */
const Body = (target, methodName, paramIndex) => {
    ensureMeta(target, methodName);
    target.__meta__[methodName].bodyIndex = paramIndex;
};
exports.Body = Body;
/**
 * Set static HTTP headers for API endpoint.
 * @param headers
 * @sample @Headers({
 *           "Content-Type": "application/x-www-form-urlencoded;charset=utf-8",
 *           "Accept": "application/json"
 *         })
 * @constructor
 */
const Headers = (headers) => {
    return (target, methodName, descriptor) => {
        ensureMeta(target, methodName);
        if (!target.__meta__[methodName].headers) {
            target.__meta__[methodName].headers = {};
        }
        target.__meta__[methodName].headers = headers;
    };
};
exports.Headers = Headers;
/**
 * Set HTTP header as variable in API method.
 * @param paramName
 * @sample @Header("X-Token") token: string
 * @constructor
 */
const Header = (paramName) => {
    return (target, methodName, paramIndex) => {
        ensureMeta(target, methodName);
        if (!target.__meta__[methodName].headerParams) {
            target.__meta__[methodName].headerParams = {};
        }
        target.__meta__[methodName].headerParams[paramIndex] = paramName;
    };
};
exports.Header = Header;
/**
 * Set header map for API endpoint.
 * @param target
 * @param methodName
 * @param paramIndex
 * @sample @HeaderMap headers: any
 * @constructor
 */
const HeaderMap = (target, methodName, paramIndex) => {
    ensureMeta(target, methodName);
    target.__meta__[methodName].headerMapIndex = paramIndex;
};
exports.HeaderMap = HeaderMap;
/**
 * Set array format for query
 * @param queryArrayFormat
 * @sample @QueryArrayFormat('repeat')
 * @constructor
 */
const QueryArrayFormat = (queryArrayFormat) => {
    return (target, methodName, descriptor) => {
        ensureMeta(target, methodName);
        target.__meta__[methodName].queryArrayFormat = queryArrayFormat;
    };
};
exports.QueryArrayFormat = QueryArrayFormat;
/**
 * Set static query for API endpoint.
 * @param query
 * @sample @Queries({
 *           page: 1,
 *           size: 20,
 *           sort: "createdAt:desc",
 *         })
 * @constructor
 */
const Queries = (query) => {
    return (target, methodName, descriptor) => {
        ensureMeta(target, methodName);
        if (!target.__meta__[methodName].query) {
            target.__meta__[methodName].query = {};
        }
        target.__meta__[methodName].query = query;
    };
};
exports.Queries = Queries;
/**
 * Set query as variable in API method.
 * @param paramName
 * @sample @Query('group') group: string
 * @constructor
 */
const Query = (paramName) => {
    return (target, methodName, paramIndex) => {
        ensureMeta(target, methodName);
        if (!target.__meta__[methodName].queryParams) {
            target.__meta__[methodName].queryParams = {};
        }
        target.__meta__[methodName].queryParams[paramIndex] = paramName;
    };
};
exports.Query = Query;
/**
 * Set query map for API endpoint.
 * @param target
 * @param methodName
 * @param paramIndex
 * @sample @QueryMap query: SearchQuery
 * @constructor
 */
const QueryMap = (target, methodName, paramIndex) => {
    ensureMeta(target, methodName);
    target.__meta__[methodName].queryMapIndex = paramIndex;
};
exports.QueryMap = QueryMap;
/**
 * 'content-type': 'application/x-www-form-urlencoded;charset=utf-8' will be added.
 * @param target
 * @param methodName
 * @param descriptor
 * @sample @FormUrlEncoded
 * @constructor
 */
const FormUrlEncoded = (target, methodName, descriptor) => {
    (0, exports.Headers)({ "content-type": "application/x-www-form-urlencoded;charset=utf-8" })(target, methodName, descriptor);
};
exports.FormUrlEncoded = FormUrlEncoded;
/**
 * Set field of form for API endpoint. Only effective when method has been decorated by @FormUrlEncoded.
 * @param paramName
 * @sample @Field("title") title: string
 * @constructor
 */
const Field = (paramName) => {
    return (target, methodName, paramIndex) => {
        ensureMeta(target, methodName);
        if (!target.__meta__[methodName].fields) {
            target.__meta__[methodName].fields = {};
        }
        target.__meta__[methodName].fields[paramIndex] = paramName;
    };
};
exports.Field = Field;
/**
 * Set field map for API endpoint.
 * @param target
 * @param methodName
 * @param paramIndex
 * @sample @FieldMap post: Post
 * @constructor
 */
const FieldMap = (target, methodName, paramIndex) => {
    ensureMeta(target, methodName);
    target.__meta__[methodName].fieldMapIndex = paramIndex;
};
exports.FieldMap = FieldMap;
/**
 * 'content-type': 'multipart/form-data' will be added to HTTP headers.
 * @param target
 * @param methodName
 * @param descriptor
 * @sample @Multipart
 * @constructor
 */
const Multipart = (target, methodName, descriptor) => {
    (0, exports.Headers)({ "content-type": "multipart/form-data" })(target, methodName, descriptor);
};
exports.Multipart = Multipart;
/**
 * Set part of form data for API endpoint. Only effective when method has been decorated by @Multipart.
 * @param paramName
 * @sample @Part("bucket") bucket: PartDescriptor<string>
 * @constructor
 */
const Part = (paramName) => {
    return (target, methodName, paramIndex) => {
        ensureMeta(target, methodName);
        if (!target.__meta__[methodName].parts) {
            target.__meta__[methodName].parts = {};
        }
        target.__meta__[methodName].parts[paramIndex] = paramName;
    };
};
exports.Part = Part;
/**
 * Set the response type for method.
 * @param responseType
 * @sample @ResponseType("stream")
 * @constructor
 */
const ResponseType = (responseType) => {
    return (target, methodName) => {
        ensureMeta(target, methodName);
        target.__meta__[methodName].responseType = responseType;
    };
};
exports.ResponseType = ResponseType;
/**
 * Set request transformer for method.
 * @param transformer
 * @sample @RequestTransformer((data: any, headers?: any) => {
 *           data.foo = 'foo';
 *           return JSON.stringify(data);
 *         })
 * @constructor
 */
const RequestTransformer = (transformer) => {
    return (target, methodName) => {
        ensureMeta(target, methodName);
        target.__meta__[methodName].requestTransformer = transformer;
    };
};
exports.RequestTransformer = RequestTransformer;
/**
 * Set response transformer for method.
 * @param transformer
 * @sample @ResponseTransformer((data: any, headers?: any) => {
 *           const json = JSON.parse(data);
 *           json.foo = 'foo';
 *           return json;
 *         })
 * @constructor
 */
const ResponseTransformer = (transformer) => {
    return (target, methodName) => {
        ensureMeta(target, methodName);
        target.__meta__[methodName].responseTransformer = transformer;
    };
};
exports.ResponseTransformer = ResponseTransformer;
/**
 * Set timeout for method, this config will shield service timeout.
 * @param timeout
 * @sample @Timeout(5000)
 * @constructor
 */
const Timeout = (timeout) => {
    return (target, methodName) => {
        ensureMeta(target, methodName);
        target.__meta__[methodName].timeout = timeout;
    };
};
exports.Timeout = Timeout;
/**
 * Declare response status code for method, do nothing just a declaration.
 * @param responseStatus
 * @sample ResponseStatus(204)
 * @constructor
 */
const ResponseStatus = (responseStatus) => {
    return (target, methodName) => {
        ensureMeta(target, methodName);
        target.__meta__[methodName].responseStatus = responseStatus;
    };
};
exports.ResponseStatus = ResponseStatus;
/**
 * A direct way to set config for a request in axios.
 * @param config
 * @sample @Config({ maxRedirects: 1 })
 * @constructor
 */
const Config = (config) => {
    return (target, methodName) => {
        ensureMeta(target, methodName);
        target.__meta__[methodName].config = config;
    };
};
exports.Config = Config;
/**
 * A easy way to send GraphQL query.
 * @param query
 * @param operationName
 * @sample @GraphQL(gqlQuery)
 * @constructor
 */
const GraphQL = (query, operationName) => {
    return (target, methodName) => {
        ensureMeta(target, methodName);
        target.__meta__[methodName].gqlQuery = query;
        target.__meta__[methodName].gqlOperationName = operationName;
    };
};
exports.GraphQL = GraphQL;
/**
 * Adds variables to GraphQL query
 * @param target
 * @param methodName
 * @param paramIndex
 * @sample @GraphQLVariables variables: any
 * @constructor
 */
const GraphQLVariables = (target, methodName, paramIndex) => {
    ensureMeta(target, methodName);
    target.__meta__[methodName].gqlVariablesIndex = paramIndex;
};
exports.GraphQLVariables = GraphQLVariables;
/**
 * Mark method as deprecated
 * @param hint
 * @sample @Deprecated("This method is deprecated on version 2.0, please use xxx.")
 * @constructor
 */
const Deprecated = (hint) => {
    return (target, methodName, descriptor) => {
        ensureMeta(target, methodName);
        target.__meta__[methodName].deprecated = true;
        target.__meta__[methodName].deprecatedHint = hint;
    };
};
exports.Deprecated = Deprecated;

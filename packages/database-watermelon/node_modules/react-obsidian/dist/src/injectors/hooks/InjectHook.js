"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectHook = exports.injectHookWithArguments = void 0;
var HookInjector_1 = __importDefault(require("./HookInjector"));
var hookInjector = new HookInjector_1.default();
// TypeScript doesn't infer generics when default types are passed in. - https://github.com/microsoft/TypeScript/issues/14400
// As a workaround, we provide two injection functions with an almost identical signature.
// 1. injectHookWithArguments: Should be used when a hook requires parameters in addition to the injected dependencies.
// 2. injectHook: Should be used when a hook does not require parameters.
function injectHookWithArguments(hook, Graph) {
    return hookInjector.inject(hook, Graph);
}
exports.injectHookWithArguments = injectHookWithArguments;
function injectHook(hook, Graph) {
    return hookInjector.inject(hook, Graph);
}
exports.injectHook = injectHook;
//# sourceMappingURL=InjectHook.js.map